<!DOCTYPE html>
<html> 
    <head>
        <title>Vue.js 设计与实现</title>
        <meta charset="utf-8">
    </head>
    <body>
        <div id="app">
            <h2>第二篇 响应系统</h2>
            <h3>第4章 响应系统的作用与实现</h3>
            <ul>
                <li><a href="/chapter04/4-2.html">4-2. 响应式数据的基本实现</a></li>
                <li><a href="/chapter04/4-3-1.html">4-3-1. 设计一个完善的响应系统，明确区分出一个依赖关系具体依赖的哪个对象的哪个字段</a></li>
                <li><a href="/chapter04/4-3-2.html">4-3-2. 把收集副作用的逻辑封装到 track 函数中；把触发副作用函数重新执行的逻辑封装到 trigger 函数中</a></li>
                <li><a href="/chapter04/4-4.html">4-4. 分支切换与 cleanup</a></li>
                <li><a href="/chapter04/4-5.html">4-5. 嵌套的 effect 与 effect 栈</a></li>
                <li><a href="/chapter04/4-6.html">4-6. 避免无限递归循环</a></li>
                <li><a href="/chapter04/4-7-1.html">4-7-1. 调度执行</a></li>
                <li><a href="/chapter04/4-7-2.html">4-7-2. 调度执行，控制执行次数</a></li>
                <li><a href="/chapter04/4-8.html">4-8. 计算属性 computed 与 lazy</a></li>
                <li><a href="/chapter04/4-9.html">4-9. watch 的实现原理</a></li>
                <li><a href="/chapter04/4-10.html">4-10. 立即执行的 watch 与回调执行时机</a></li>
                <li><a href="/chapter04/4-11.html">4-11. 过期的副作用</a></li>
            </ul>
            <h3>第5章 非原始值的响应式方案</h3>
            <ul>
                <li><a href="/chapter05/5-3.html">5-3. 理解 Proxy 和 Reflect，代理 Object</a></li>
                <li><a href="/chapter05/5-4.html">5-4. 合理的触发响应</a></li>
                <li><a href="/chapter05/5-5.html">5-5. 浅响应与深响应</a></li>
                <li><a href="/chapter05/5-6.html">5-6. 只读与浅只读</a></li>
                <li><a href="/chapter05/5-7-1.html">5-7-1. 代理数组 - 数组的索引与 length</a></li>
                <li><a href="/chapter05/5-7-2.html">5-7-2. 代理数组 - 遍历数组</a></li>
                <li><a href="/chapter05/5-7-3.html">5-7-3. 代理数组 - 数组的查找方法</a></li>
                <li><a href="/chapter05/5-7-4.html">5-7-4. 代理数组 - 隐式修改数组长度的原型方法</a></li>
                <li><a href="/chapter05/5-8-1.html">5-8-1. 代理 Set 和 Map - 如何代理 Set 和 Map</a></li>
                <li><a href="/chapter05/5-8-2.html">5-8-2. 代理 Set 和 Map - 建立响应联系</a></li>
                <li><a href="/chapter05/5-8-3.html">5-8-3. 代理 Set 和 Map - 避免污染原始数据</a></li>
                <li><a href="/chapter05/5-8-4.html">5-8-4. 代理 Set 和 Map - 处理 forEach</a></li>
                <li><a href="/chapter05/5-8-5.html">5-8-5. 代理 Set 和 Map - 迭代器方法</a></li>
                <li><a href="/chapter05/5-8-6.html">5-8-6. 代理 Set 和 Map - values 和 keys 方法</a></li>
            </ul>
            <h3>第6章 原始值的响应式方案</h3>
            <ul>
                <li><a href="/chapter06/6-1.html">6-1. 引入 ref 的概念</a></li>
                <li><a href="/chapter06/6-2.html">6-2. 响应丢失问题</a></li>
                <li><a href="/chapter06/6-3.html">6-3. 自动脱 ref</a></li>
            </ul>
            <h2>第三篇 渲染器</h2>

            <h3>第7章 渲染器的设计</h3>
            <ul>
                <li><a href="/chapter07/index.html">7. 渲染器的设计</a></li>
            </ul>
            
            <h3>第8章 挂载与更新</h3>
            <ul>
                <li><a href="/chapter08/01/index.html">8-1. 挂载子节点和元素属性</a></li>
                <li><a href="/chapter08/03/index.html">8-3. 正确地设置元素属性</a></li>
                <li><a href="/chapter08/04/index.html">8-4. class 的处理</a></li>
                <li><a href="/chapter08/05/index.html">8-5. 卸载操作</a></li>
                <li><a href="/chapter08/06/index.html">8-6. 区分 vnode 的类型</a></li>
                <li><a href="/chapter08/07/index.html">8-7. 事件的处理</a></li>
            </ul>
        </div>
    </body>
</html>