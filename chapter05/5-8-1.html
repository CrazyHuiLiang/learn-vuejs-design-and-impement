<!DOCTYPE html>
<html> 
    <head>
        <title>5-8-1. 代理 Set 和 Map - 如何代理 Set 和 Map</title>
        <meta charset="utf-8">
    </head>
    <body>
        <script>
            /*
                Set 的 size 是一个访问器属性，其语义依赖了 this[[SetData]]，通过代理访问 size 时 this 的值指向代理，其没有 [[SetData]] 的内部插槽，会导致报错，处理方法是在 get 拦截中判断如果是读取 size 属性，通过 Reflect.get 指定 this 值为 Set

                访问 Set 的 delete 函数时，因为 this 指向了代理，同样会导致报错，解决方法是在获取 delete 函数时，将this绑定为 Set
            */
            (() => {

                // 用一个全局变量存储当前激活的 effect 函数
                let activeEffect = null;
                // effect 栈
                const effectStack = [];
                // 一个标记变量，代表是否进行追踪
                let shouldTrack = true;

                const ITERATRE_KEY = Symbol();
                const TriggerType = {
                    SET: 'SET',
                    ADD: 'ADD',
                    DELETE: 'DELETE',
                };

                function track(target, key) {
                    // 没有 activeEffect，直接返回
                    if (!activeEffect || !shouldTrack) {
                        return target[key];
                    }

                    // 根据 target 从桶中取得 depsMap，它是一个 Map 类型：key -> effects
                    let depsMap = bucket.get(target);
                    // 如果不存在 depsMap，则创建一个新的 Map 并与 target 关联
                    if (!depsMap) {
                        bucket.set(target, (depsMap = new Map()));
                    }

                    // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型
                    // 里面存储所有与当前 key 关联的副作用函数
                    let deps = depsMap.get(key);
                    // 如果不存在 deps，则创建一个新的 Set 并与 key 关联
                    if (!deps) {
                        depsMap.set(key, (deps = new Set()));
                    }

                    // 最后将当前激活的副作用函数添加到依赖集合中
                    deps.add(activeEffect);

                    // 将依赖收集的集合保存到副作用函数的deps中
                    activeEffect.deps.push(deps);
                }

                function trigger(target, key, type, newVal) {
                    console.log('trigger', key, type);
                    // 根据 target 从桶中取得 depsMap，它存储着 key -> effects
                    const depsMap = bucket.get(target);
                    if (!depsMap) return true;
                    // 根据 key 取得所有副作用函数
                    const effects = depsMap.get(key) || [];

                    // 只有当操作类型为 ADD 或 DELETE 时，取得与 ITERATE_KEY 相关联的副作用函数，将其也添加到 effectToRun
                    const iterateEffects = [TriggerType.ADD, TriggerType.DELETE].includes(type) ? depsMap.get(ITERATRE_KEY) : [];

                    // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行
                    const effectsToRun = new Set([...effects, ...(iterateEffects || [])].filter(effect => effect !== activeEffect));

                    // 当操作位 ADD 并且目标是数组时，应该取出并执行那些与 length 属性相关联的副作用函数
                    if (type === TriggerType.ADD && Array.isArray(target)) {
                        // 取出与 length 相关联的副作用函数
                        const lengthEffects = depsMap.get('length') || [];
                        lengthEffects.forEach(effectFn => {
                            if (effectFn !== activeEffect) {
                                effectsToRun.add(effectFn);
                            }
                        });
                    }

                    // 如果操作目标是数组，并且修改了数组的 length 属性
                    if (Array.isArray(target) && key === 'length') {
                        // 对于索引大于或等于新的 length 值的元素，需要把所有相关联的副作用函数取出并添加到 effectToRun 中待执行
                        depsMap.forEach((effects, depKey) => {
                            console.log('depKey', depKey);
                            if (depKey >= newVal) {
                                effects.forEach(effectFn => {
                                    if (effectFn !== activeEffect) {
                                        effectsToRun.add(effectFn);
                                    }
                                });
                            }
                        });
                    }

                    effectsToRun.forEach(effect => {
                        if (effect.options.scheduler) {
                            effect.options.scheduler(effect);
                        } else {
                            effect();
                        }
                    });
                }

                // 只读
                function readonly(obj) {
                    return reactive(obj, false, true);
                }
                function shallowReadonly(obj) {
                    return reactive(obj, true, true);
                }

                // 重写数组的索引方法
                const arrayInstrumentations = {};
                ['includes', 'indexOf', 'lastIndexOf'].forEach(method => {
                    const originMethod = Array.prototype[method];
                    arrayInstrumentations[method] = function (...args) {
                        // this 是代理对象，现在代理对象中查找，将结果存储在 res 中
                        let res = originMethod.apply(this, args);
                        if (res === false) {
                            // res 为 false 说明没找到，通过 this.raw 拿到原始数据，再去其中查找，并更新 res 值
                            res = originMethod.apply(this.raw, args);
                        }
                        return res;
                    };
                });
                // 重写数组方法
                ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method => {
                    const originMethod = Array.prototype[method];
                    arrayInstrumentations[method] = function (...args) {
                        // 调用原始方法前禁止追踪
                        shouldTrack = false;
                        // 方法默认的行为
                        let res = originMethod.apply(this, args);
                        // 调用原始方法之后，恢复原来的行为
                        shouldTrack = true;
                        return res;
                    }
                });


                // 创建响应式数据
                function createReactive(data, isShallow = false, isReadonly = false) {

                    // 对原始数据的代理
                    const proxy = new Proxy(data, {
                        // 拦截读取操作
                        get(target, key, receiver) {
                            console.log('get', target, key);
                            // 代理对象可以通过 raw 属性访问原始数据
                            if (key === 'raw') {
                                return target;
                            }

                            // Set 和 Map
                            if (target instanceof Map || target instanceof Set) {
                                if (key === 'size') {
                                    return Reflect.get(target, key, target);
                                }
                                return target[key].bind(target);
                            }

                            // 如果操作的目标对象是数组，并且 key 存在于 arrayInstrumentations 上
                            // 那么返回定义在 arrayInstrumentations 上的值
                            if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) {
                                return Reflect.get(arrayInstrumentations, key, receiver);
                            }

                            // 只读数据因为数据不会变也就不需要侦听变化
                            if (!isReadonly && typeof key !== "symbol") {
                                track(target, key);
                            }
                            // 返回属性值
                            // return target[key];
                            // 使用 Reflect.get 返回读取到的属性值，receiver 代表谁在读取属性
                            const res = Reflect.get(target, key, receiver);

                            // 如果是浅响应，则直接返回原始值
                            if (isShallow) {
                                return res;
                            }
                            // 如果 res 是普通对象，调用 reactive 包装成响应式数据并返回
                            if (typeof res === 'object' && res !== null) {
                                // 如果数据为只读，则调用 readonly 对值进行包装
                                return isReadonly ? readonly(res) : reactive(res);
                            }

                            return res;
                        },
                        // 拦截设置操作
                        set(target, key, value, receiver) {
                            if (isReadonly) {
                                console.warn(`set：属性 ${key} 是只读的`);
                                return;
                            }
                            console.log('set', target, key, value);

                            // 先获取旧值
                            const oldVal = target[key];
                            // 如果属性不存在，则说明是在添加新属性，否则是设置已有属性
                            const type = Array.isArray(target) ? Number(key) < target.length ? TriggerType.SET : TriggerType.ADD
                                        : Object.prototype.hasOwnProperty.call(target, key) ? TriggerType.SET : TriggerType.ADD;


                            // 设置属性值
                            // target[key] = value;
                            const res = Reflect.set(target, key, value, receiver);

                            // target === receiver.raw 说明 receiver 就是 target 的代理对象，而不是 target 原型代理对象
                            if (target === receiver.raw) {
                                // 当新旧值不相等时才触发响应，规避 NaN 不全等 NaN，所以需要对此 NaN 的情况做特殊判断
                                if (oldVal !== value && (oldVal === oldVal || value === value)) {
                                    // 将 type 作为第三个参数传递给 trigger
                                    trigger(target, key, type, value);
                                }
                            }
                            return res;
                        },
                        // has 拦截 in 操作符的代理
                        has(target, key) {
                            console.log('has', target, key);
                            track(target, key);
                            return Reflect.has(target, key);
                        },
                        // ownKeys 拦截 for...in
                        ownKeys(target) {
                            console.log('ownKeys', target);
                            // 将副作用函数与 ITERATE_KEY 关联
                            track(target, Array.isArray(target) ? 'length' : ITERATRE_KEY);
                            return Reflect.ownKeys(target);
                        },
                        // 拦截 delete 操作
                        deleteProperty(target, key) {
                            if (isReadonly) {
                                console.warn(`deleteProperty：属性 ${key} 是只读的`);
                                return;
                            }
                            console.log('deleteProperty', arguments);
                            // 检查被操作的属性是否是对象自己的属性
                            const hadKey = Object.prototype.hasOwnProperty.call(target, key);
                            // 使用 Reflect.deleteProperty 完成属性的删除
                            const res = Reflect.deleteProperty(target, key);

                            // 当被删除的属性是对象自己的属性，且删除成功时，才触发更新
                            if (res && hadKey) {
                                trigger(target, key, TriggerType.DELETE);
                            }
                            return res;
                        },
                    })
                    
                    return proxy;
                }

                // 定义一个 Map 实例，存储原始对象到代理对象的映射
                const reactiveMap = new Map();

                function reactive(obj, isShallow = false, isReadonly = false) {
                    const existionProxy = reactiveMap.get(obj);
                    if (existionProxy) {
                        return existionProxy;
                    }
                    const proxy = createReactive(obj, isShallow, isReadonly);
                    // 存储到 Map 中，从而帮助重复创建
                    reactiveMap.set(obj, proxy);
                    return proxy;
                }

                function shallowReactive(data) {
                    return reactive(data, true);
                }

                // 存储副作用函数的桶
                const bucket = new WeakMap();

                // 用于注册副作用函数
                function effect(fn, options = {}) {
                    const effectFn = () => {
                        // 调用 cleanup 函数来清除对当前副作用函数的依赖
                        cleanup(effectFn);

                        // 当前活跃的副作用函数
                        activeEffect = effectFn;

                        // 在调用副作用函数之前，将当前副作用函数压入栈中
                        effectStack.push(effectFn);
                        const res = fn();
                        // 当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把 activeEffect 还原为之前的值
                        effectStack.pop();
                        activeEffect = effectStack[effectStack.length - 1];
                        // 将副作用函数的返回值返回
                        return res;
                    };

                    // 将 options 挂载到 effectFn 上
                    effectFn.options = options;
                    // 用于收集副作用函数被哪些响应式数据所依赖
                    effectFn.deps = [];

                    // 如果没有设置 lazy，执行副作用函数
                    if (!options.lazy) {
                        // 执行副作用函数
                        effectFn();
                    }
                    return effectFn;
                }

                function computed(getter) {
                    // 用来缓存上一次计算的值
                    let value;
                    // 用来标识是否需要重新计算值，为 true 意味着需要重新计算
                    let dirty = true;

                    // 把 getter 作为副作用函数，创建一个 lazy 的 effect
                    const effectFn = effect(getter, {
                        lazy: true,
                        // 添加调度器，在调度器中将 dirty 重置为 true
                        scheduler() {
                            // 此调度器不需要承担副作用函数的执行，也就不需要接收副作用函数，只需要将 dirty 标志位置为 true，在读取 computed 的值时，自会重新触发副作用函数的包装函数获取新的值
                            dirty = true;

                            // 当计算属性依赖的响应式数据变化时，手动调用 trigger 函数触发响应
                            trigger(obj, 'value');
                        }
                    });
                    // obj 的响应式不使用 Proxy 来实现，通过 get 函数来 track 依赖，getter 的依赖发生变化时触发 scheduler 的执行，在 scheduler 中可以进行依赖函数的 trigger
                    const obj = {
                        // 当读取 value 时才执行 effectFn
                        get value() {
                            if (dirty) {
                                value = effectFn();
                                dirty = true;
                            }
                            // 当读取 value 时，手动调用 track 函数进行追踪
                            track(obj, 'value');
                            return value;
                        }
                    }
                    return obj;
                }

                // 清除对当前副作用函数的依赖
                function cleanup(effectFn) {
                    for (let i = 0; i < effectFn.deps.length; i++) {
                        const deps = effectFn.deps[i];
                        deps.delete(effectFn);
                    }
                    // 重置 effectFn.deps 数组
                    effectFn.deps.length = 0;
                }




                /*
                    除了控制副作用函数的执行顺序，通过调度器还可以控制它执行的次数
                */
                // 定义一个任务队列
                const jobQueue = new Set;
                // 创建一个 promise 实例
                const p = Promise.resolve();

                let isFlushing = false;
                function flushJob() {
                    if (isFlushing) {
                        return;
                    }
                    isFlushing = true;
                    p.then(() => {
                        jobQueue.forEach(job => job());
                    }).finally(() => {
                        isFlushing = false;
                    });
                }


                // 递归访问对象的所有的值
                function traverse(value, seen = new Set()) {
                    // 如果读取的数据是原始值，或者已经被读取过了，那么什么都不做
                    if (typeof value !== 'object' || value === null || seen.has(value)) {
                        return;
                    }
                    // 将数据添加到 seen 中，代表遍历地读取过了，避免循环引用引起的死循环
                    seen.add(value);
                    // 暂时不考虑数组等其他结构

                    // 假设 value 就是一个对象，使用 for...in 读取对象的每一个值，并递归地调用 traverse 进行处理
                    for (const k in value) {
                        traverse(value[k], seen);
                    }
                    return value;
                }

                function watch(source, cb, options = {}) {
                    let getter;
                    if (typeof source === 'function') {
                        getter = source;
                    } else {
                        getter = () => traverse(source);
                    }

                    // 定义旧值与新值
                    let oldValue, newValue;

                    // cleanup 用来存储用户注册的过期回调
                    let cleanup;
                    // 定义 onInvalidate 函数
                    function onInvalidate(fn) {
                        cleanup = fn;
                    }

                    const job = () => {
                        
                        // 重新执行副作用函数，得到的就是新值
                        newValue = effectFn();

                        // 在调用回调函数之前，先调用过期回调
                        if (cleanup) {
                            cleanup();
                            cleanup = null;
                        }
                        // 将旧值和新值作为回调函数的参数
                        cb(newValue, oldValue, onInvalidate);
                        // 更新旧值，不然下一次会得到错误的旧值
                        oldValue = newValue;
                    };


                    // 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中，以便后续手动调用
                    const effectFn = effect(() => getter(), {
                        lazy: true,
                        // 使用 job 函数作为调度器函数
                        scheduler: () => {
                            // 在 Vue.js3 中，使用 flush 配置指定回调函数的执行时机，其中 pre 和 post 原本语义是指组件更新前和更新后
                            if (options.flush === 'post') {
                                // 如果 flush 为 post，将其放在微任务队列中执行
                                Promise.resolve().then(job);
                            } else {
                                job();
                            }
                        },
                    });


                    if (options.immediate) {
                        // 当 immediate 为 true 时，立即执行 job，从而触发回调执行
                        job();
                    } else {
                        // 手动调用副作用函数，拿到的值就是旧值
                        oldValue = effectFn();
                    }
                }

                (() => {
                    console.group('代理 Set');
                    const s = new Set([1, 2, 3]);
                    const p = reactive(s)
                    effect(() => {
                        console.log(p.size);
                        p.delete(1);
                    });
                    console.log('------------');
                    console.groupEnd();
                })();
            })();
        </script>
    </body>
</html>